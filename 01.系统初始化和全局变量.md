tags: environment

# 01.系统初始化和全局变量

<!-- TOC -->

- [01.系统初始化和全局变量](#01系统初始化和全局变量)
    - [集群机器](#集群机器)
    - [主机名](#主机名)
    - [添加 docker 账户](#添加-docker-账户)
    - [无密码 ssh 登录其它节点](#无密码-ssh-登录其它节点)
    - [更新 PATH 变量](#更新-path-变量)
    - [安装依赖包](#安装依赖包)
    - [关闭防火墙](#关闭防火墙)
    - [关闭 swap 分区](#关闭-swap-分区)
    - [关闭 SELinux](#关闭-selinux)
    - [关闭 dnsmasq（可选）](#关闭-dnsmasq可选)
    - [加载内核模块](#加载内核模块)
    - [优化内核参数](#优化内核参数)
    - [设置系统时区](#设置系统时区)
    - [关闭无关的服务](#关闭无关的服务)
    - [设置 rsyslogd 和 systemd journald](#设置-rsyslogd-和-systemd-journald)
    - [创建相关目录](#创建相关目录)
    - [升级内核](#升级内核)
    - [关闭 NUMA](#关闭-numa)
    - [分发集群配置参数脚本](#分发集群配置参数脚本)
    - [参考](#参考)

<!-- /TOC -->

## 集群机器

| IP         | HOSTNAME | CPU  | MEMORY |
| ---------- | -------- | ---- | ------ |
| 10.1.80.71 | k8s-m1   | 2    | 4G     |
| 10.1.80.72 | k8s-m2   | 2    | 4G     |
| 10.1.80.73 | k8s-m3   | 2    | 4G     |
| 10.1.80.74 | k8s-n1   | 2    | 4G     |

注意：
1. 本文档中的 etcd 集群、master 节点、worker 节点均使用这三台机器；

2. 需要在**所有机器**上执行本文档的初始化命令；

3. 需要使用 **root 账号**执行这些命令；

4. 如果没有特殊指明，本文档的所有操作**均在 k8s-m1 节点上执行**，然后远程分发文件和执行命令；

5. 下面有些是在CentOS上才有的服务，在Ubuntu18.04上在执行以下初始化操作的时候可能会遇到

   类似这样的Failed to restart crond.service: Unit crond.service not found.错误，忽略就好，没关系的

   比如像firewall selinux dnsmaq,postfix

   ​
   
   先创建目录，
   
   ```
   mkdir -p /opt/k8s/{bin,work}
   ```
   
   按情况修改environment.sh,并传到k8s-m1节点的/opt/k8s/bin目录下
   
   ​

## 无密码 ssh 登录其它节点

如果没有特殊指明，本文档的所有操作**均在 k8s-m1 节点上执行**，然后远程分发文件和执行命令，所以需要添加该节点到其它节点的 ssh 信任关系。

设置 k8s-m1 的 root 账户可以无密码登录**所有节点**：

```bash

ssh-keygen -t rsa

cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
echo ">>> $node_ip"
ssh-copy-id -i root@$node_ip
done
```

## 主机名

+ 设置的主机名保存在 `/etc/hostname` 文件中；

如果 DNS 不支持解析主机名称，则需要修改每台机器的 `/etc/hosts` 文件，添加主机名和 IP 的对应关系：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
echo "" > hosts.txt
for node_name in ${!ALL_NODES[@]}; do 
  echo ${ALL_NODES[$node_name]} $node_name >> hosts.txt
done

# 批量设置hosts
for node_ip in ${ALL_NODES[@]}; do 
echo ">>> ${node_ip}"
cat << EOF | ssh root@${node_ip} 'cat - >> /etc/hosts'
   `cat hosts.txt`
EOF
done
```

设置永久主机名称，然后重新登录:

```bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_name in ${!ALL_NODES[@]};do 
   echo ">>> ${node_name} ${ALL_NODES[$node_name]}"
   ssh root@${ALL_NODES[$node_name]} hostnamectl set-hostname ${node_name}
done
```

## 添加 docker 账户

在每台机器上添加 docker 账户：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
   echo ">>> ${node_ip}"
   ssh root@${node_ip} useradd -m docker
done
```

## 更新 PATH 变量

将可执行文件目录添加到 PATH 环境变量中：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
echo "export PATH=$PATH:/opt/k8s/bin" > path.txt
for node_name in ${!ALL_NODES[@]}; do
echo ">>> ${node_name} ${ALL_NODES[$node_name]}"
cat << EOF | ssh root@${ALL_NODES[$node_name]} 'cat - >> /root/.bashrc'
`cat path.txt`
EOF
done

for node_name in ${!ALL_NODES[@]}; do
echo ">>> ${node_name} ${ALL_NODES[$node_name]}"
ssh root@${ALL_NODES[$node_name]} source /root/.bashrc
done
```



## 更换软件源

默认的软件源很慢，换成阿里云的
```shell
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_name in ${!ALL_NODES[@]}; do
 echo $node_name ${ALL_NODES[$node_name]}
 cp /etc/apt/sources.list{,.bak}
 # todo 看下ubuntu默认的软件源地址
 sed -i "s#http://archive.ubuntu.com#https://mirrors.aliyun.com#g" /etc/apt/sources.list
 sed -i "s#http://security.ubuntu.com#https://mirrors.aliyun.com#g" /etc/apt/sources.list
 apt update -y
done
```

## 安装依赖包

在每台机器上安装依赖包：

CentOS:

``` bash
yum install -y epel-release
yum install -y conntrack ntpdate ntp ipvsadm ipset jq iptables curl sysstat libseccomp wget
```

Ubuntu: 

``` bash
apt-get install -y conntrack ipvsadm ntp ipset jq iptables curl sysstat libseccomp2
```

+ ipvs 依赖 ipset；
+ ntp 保证各机器系统时间同步；

## 关闭防火墙

在每台机器上关闭防火墙，清理防火墙规则，设置默认转发策略：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"
    ssh root@$node_ip "systemctl disable --now firewalld || echo firewalld not exists"
    ssh root@$node_ip "systemctl disable --now NetworkManager || echo NetworkManager not exists"
    ssh root@$node_ip "iptables -F && iptables -X && iptables -F -t nat && iptables -X -t nat && echo iptables ok1"
    ssh root@$node_ip "iptables -P FORWARD ACCEPT && echo iptables ok2"
done
```

## 关闭 swap 分区

如果开启了 swap 分区，kubelet 会启动失败(可以通过将参数 --fail-swap-on 设置为 false 来忽略 swap on)，故需要在每台机器上关闭 swap 分区。同时注释 `/etc/fstab` 中相应的条目，防止开机自动挂载 swap 分区：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
 echo ">>> $node_ip"
 ssh root@$node_ip swapoff -a && sysctl -w vm.swappiness=0 
 ssh root@$node_ip sed -ri '/^[^#]*swap/s@^@#@' /etc/fstab
done 
```

## 关闭 SELinux

关闭 SELinux，否则后续 K8S 挂载目录时可能报错 `Permission denied`：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"
    ssh root@$node_ip setenforce 0
    ssh root@$node_ip sed -i 's/^SELINUX=.*/SELINUX=disabled/' /etc/selinux/config
done
```

## 关闭 dnsmasq（可选）

linux 系统开启了 dnsmasq 后(如 GUI 环境)，将系统 DNS Server 设置为 127.0.0.1，这会导致 docker 容器无法解析域名，需要关闭它：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"
	ssh root@$node_ip systemctl disable --now dnsmasq
done	
```

## 加载内核模块

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"
	ssh root@$node_ip modprobe ip_vs_rr && modprobe br_netfilter
done
```

## 优化内核参数

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
cat > kubernetes.conf <<EOF
net.bridge.bridge-nf-call-iptables=1
net.bridge.bridge-nf-call-ip6tables=1
net.ipv4.ip_forward=1
net.ipv4.tcp_tw_recycle=0
vm.swappiness=0 # 禁止使用 swap 空间，只有当系统 OOM 时才允许使用它
vm.overcommit_memory=1 # 不检查物理内存是否够用
vm.panic_on_oom=0 # 开启 OOM
fs.inotify.max_user_instances=8192
fs.inotify.max_user_watches=1048576
fs.file-max=52706963
fs.nr_open=52706963
net.ipv6.conf.all.disable_ipv6=1
net.netfilter.nf_conntrack_max=2310720
EOF

for node_ip in ${ALL_NODES[@]}; do
	echo ">>> $node_ip"
	scp kubernetes.conf  root@$node_ip:/etc/sysctl.d/kubernetes.conf
	ssh root@$node_ip sysctl -p /etc/sysctl.d/kubernetes.conf
done	
```
+ 必须关闭 tcp_tw_recycle，否则和 NAT 冲突，会导致服务不通；
+ 关闭 IPV6，防止触发 docker BUG；

## 设置系统时区 

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"

    # 调整系统 TimeZone
    ssh root@$node_ip timedatectl set-timezone Asia/Shanghai

    # 将当前的 UTC 时间写入硬件时钟
    ssh root@$node_ip timedatectl set-local-rtc 0

    # 重启依赖于系统时间的服务
    ssh root@$node_ip systemctl restart rsyslog 
    ssh root@$node_ip systemctl restart cron
done   
```

## 关闭无关的服务

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"
	ssh root@$node_ip systemctl disable --now postfix
done	
```

## 设置 rsyslogd 和 systemd journald

systemd 的 journald 是 Centos 7 缺省的日志记录工具，它记录了所有系统、内核、Service Unit 的日志。

相比 systemd，journald 记录的日志有如下优势：

1. 可以记录到内存或文件系统；(默认记录到内存，对应的位置为 /run/log/jounal)；
1. 可以限制占用的磁盘空间、保证磁盘剩余空间；
1. 可以限制日志文件大小、保存的时间；

journald 默认将日志转发给 rsyslog，这会导致日志写了多份，/var/log/messages 中包含了太多无关日志，不方便后续查看，同时也影响系统性能。

``` bash
cd /opt/k8s/work

cat > 99-prophet.conf <<EOF
[Journal]
# 持久化保存到磁盘
Storage=persistent

# 压缩历史日志
Compress=yes

SyncIntervalSec=5m
RateLimitInterval=30s
RateLimitBurst=1000

# 最大占用空间 10G
SystemMaxUse=10G

# 单日志文件最大 200M
SystemMaxFileSize=200M

# 日志保存时间 2 周
MaxRetentionSec=2week

# 不将日志转发到 syslog
ForwardToSyslog=no
EOF
```

 分发99-prophet.conf配置文件

```bash
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"
    scp 99-prophet.conf root@$node_ip:/etc/systemd/journald.conf.d/99-prophet.conf
    ssh root@$node_ip mkdir /var/log/journal # 持久化保存日志的目录
    ssh root@$node_ip mkdir /etc/systemd/journald.conf.d
    ssh root@$node_ip systemctl restart systemd-journald
done
```



## 创建相关目录

创建目录：

``` bash
cd /opt/k8s/work
source /opt/k8s/bin/environment.sh
for node_ip in ${ALL_NODES[@]}; do
    echo ">>> $node_ip"
	ssh root@$node_ip mkdir -p  /opt/k8s/{bin,work} /etc/{kubernetes,etcd}/cert
done
```

## 升级内核 

### CentOS 7.x升级内核

CentOS 7.x 系统自带的 3.10.x 内核存在一些 Bugs，导致运行的 Docker、Kubernetes 不稳定，例如：
1. 高版本的 docker(1.13 以后) 启用了 3.10 kernel 实验支持的 kernel memory account 功能(无法关闭)，当节点压力大如频繁启动和停止容器时会导致 cgroup memory leak；
2. 网络设备引用计数泄漏，会导致类似于报错："kernel:unregister_netdevice: waiting for eth0 to become free. Usage count = 1";

解决方案如下：
1. 升级内核到 4.4.X 以上；
2. 或者，手动编译内核，disable CONFIG_MEMCG_KMEM 特性；
3. 或者，安装修复了该问题的 Docker 18.09.1 及以上的版本。但由于 kubelet 也会设置 kmem（它 vendor 了 runc），所以需要重新编译 kubelet 并指定 GOFLAGS="-tags=nokmem"；
  ``` bash
  git clone --branch v1.14.1 --single-branch --depth 1 https://github.com/kubernetes/kubernetes
  cd kubernetes
  KUBE_GIT_VERSION=v1.14.1 ./build/run.sh make kubelet GOFLAGS="-tags=nokmem"
  ```

这里采用升级内核的解决办法：

``` bash
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm
# 安装完成后检查 /boot/grub2/grub.cfg 中对应内核 menuentry 中是否包含 initrd16 配置，如果没有，再安装一次！
yum --enablerepo=elrepo-kernel install -y kernel-lt
# 设置开机从新内核启动
grub2-set-default 0
```

安装内核源文件（可选，在升级完内核并重启机器后执行）:

``` bash
# yum erase kernel-headers
yum --enablerepo=elrepo-kernel install kernel-lt-devel-$(uname -r) kernel-lt-headers-$(uname -r)
```



### Ubuntu 18.04 升级内核

下载安装文件：

https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-headers-4.19.56-041956_4.19.56-041956.201906250431_all.deb

https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-headers-4.19.56-041956-generic_4.19.56-041956.201906250431_amd64.deb

https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-image-unsigned-4.19.56-041956-generic_4.19.56-041956.201906250431_amd64.deb

https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-modules-4.19.56-041956-generic_4.19.56-041956.201906250431_amd64.deb

```bash
cd /opt/k8s/work

wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-headers-4.19.56-041956_4.19.56-041956.201906250431_all.deb

wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-headers-4.19.56-041956-generic_4.19.56-041956.201906250431_amd64.deb

wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-headers-4.19.56-041956_4.19.56-041956.201906250431_all.deb

wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-image-unsigned-4.19.56-041956-generic_4.19.56-041956.201906250431_amd64.deb

wget https://kernel.ubuntu.com/~kernel-ppa/mainline/v4.19.56/linux-modules-4.19.56-041956-generic_4.19.56-041956.201906250431_amd64.deb

source /opt/k8s/bin/enviroment.sh
for node_ip in ${OTHER_NODES[@]}; do
echo ">>> $node_ip"
scp linux*.deb root@$node_ip:/opt/k8s/work
done

```

安装新内核

```bash
cd /opt/k8s/work
source /opt/k8s/bin/enviroment.sh
for node_ip in ${ALL_NODES[@]}; do
echo ">>> $node_ip"
ssh root@$node_ip dpkg -i /opt/k8s/work/linux*.deb
done
```

清理老的内核

```

# 查看老的内核的版本，笔者这里旧内核是4.15.0
root@host00:~# dpkg -l | grep linux
ii  console-setup-linux                         1.178ubuntu2.7                    all          Linux specific part of console-setup
ii  libselinux1:amd64                           2.7-2build2                       amd64        SELinux runtime shared libraries
ii  linux-base                                  4.5ubuntu1                        all          Linux image base package
ii  linux-firmware                              1.173.6                           all          Firmware for Linux kernel drivers
ii  linux-generic                               4.15.0.52.54                      amd64        Complete Generic Linux kernel and headers
ii  linux-headers-4.15.0-52                     4.15.0-52.56                      all          Header files related to Linux kernel version 4.15.0
ii  linux-headers-4.15.0-52-generic             4.15.0-52.56                      amd64        Linux kernel headers for version 4.15.0 on 64 bit x86 SMP
ii  linux-headers-4.19.56-041956                4.19.56-041956.201906250431       all          Header files related to Linux kernel version 4.19.56
ii  linux-headers-4.19.56-041956-generic        4.19.56-041956.201906250431       amd64        Linux kernel headers for version 4.19.56 on 64 bit x86 SMP
ii  linux-headers-generic                       4.15.0.52.54                      amd64        Generic Linux kernel headers
ii  linux-image-4.15.0-52-generic               4.15.0-52.56                      amd64        Signed kernel image generic
ii  linux-image-generic                         4.15.0.52.54                      amd64        Generic Linux kernel image
ii  linux-image-unsigned-4.19.56-041956-generic 4.19.56-041956.201906250431       amd64        Linux kernel image for version 4.19.56 on 64 bit x86 SMP
ii  linux-modules-4.15.0-52-generic             4.15.0-52.56                      amd64        Linux kernel extra modules for version 4.15.0 on 64 bit x86 SMP
ii  linux-modules-4.19.56-041956-generic        4.19.56-041956.201906250431       amd64        Linux kernel extra modules for version 4.19.56 on 64 bit x86 SMP
ii  linux-modules-extra-4.15.0-52-generic       4.15.0-52.56                      amd64        Linux kernel extra modules for version 4.15.0 on 64 bit x86 SMP
ii  util-linux                                  2.31.1-0.4ubuntu3.3               amd64        miscellaneous system utilities

```

```bash
# 清理旧内核，根据情况修改内核版本
#cd /opt/k8s/work
#source /opt/k8s/bin/enviroment.sh
#for node_ip in ${ALL_NODES[@]}; do
#echo ">>> $node_ip"
#ssh root@$node_ip apt purge linux*4.15.0* -y
#done

apt purge linux*4.15.0* -y
```



## 关闭 NUMA 

* CentOS7

``` bash
cp /etc/default/grub{,.bak}
vim /etc/default/grub # 在 GRUB_CMDLINE_LINUX 一行添加 `numa=off` 参数，如下所示：
diff /etc/default/grub.bak /etc/default/grub
6c6
< GRUB_CMDLINE_LINUX="crashkernel=auto rd.lvm.lv=centos/root rhgb quiet"
---
> GRUB_CMDLINE_LINUX="crashkernel=auto rd.lvm.lv=centos/root rhgb quiet numa=off"
```

以上也可以直接用sed来搞定

```bash
# (\s*)表示空格，\4表示分组4，也就是原=右边双引号内的内容
ssh root@$node_name sed  -i -r -e 's/(\s*)GRUB_CMDLINE_LINUX(\s*)=(\s*)\"(.*)\"(\s*)/GRUB_CMDLINE_LINUX=\"\4 numa=off\"/g' /etc/default/grub
```

重新生成 grub2 配置文件：

``` bash
cp /boot/grub2/grub.cfg{,.bak}
grub2-mkconfig -o /boot/grub2/grub.cfg
```

*　Ubuntu18.04

```bash
# 这个操作没法分发，只能到节点上各自执行了
sed -i -r -e 's/(\s*)GRUB_CMDLINE_LINUX(\s*)=(\s*)\"(.*)\"(\s*)/GRUB_CMDLINE_LINUX=\"numa=off\"/g' /etc/default/grub
```

重新生成 grub2 配置文件：

```bash
cp /boot/grub/grub.cfg{,.bak}
grub-mkconfig -o /boot/grub/grub.cfg
```



## 分发集群配置参数脚本

后续使用的环境变量都定义在文件 [environment.sh](manifests/environment.sh) 中，请根据**自己的机器、网络情况**修改。然后，把它拷贝到**所有**节点的 `/opt/k8s/bin` 目录：

``` bash
cd /opt/k8s/bin
source environment.sh
for node_ip in ${ALL_NODES[@]}
  do
    echo ">>> ${node_ip}"
    scp environment.sh root@${node_ip}:/opt/k8s/bin/
    ssh root@${node_ip} "chmod +x /opt/k8s/bin/*"
done
```

## 参考

1. 系统内核相关参数参考：https://docs.openshift.com/enterprise/3.2/admin_guide/overcommit.html
2. 3.10.x 内核 kmem bugs 相关的讨论和解决办法：
    1. https://github.com/kubernetes/kubernetes/issues/61937
    2. https://support.mesosphere.com/s/article/Critical-Issue-KMEM-MSPH-2018-0006
    3. https://pingcap.com/blog/try-to-fix-two-linux-kernel-bugs-while-testing-tidb-operator-in-k8s/